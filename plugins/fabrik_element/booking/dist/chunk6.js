import{am as ne,an as se,ao as ie,ap as x,aq as H,ar as C,as as U,at as G,au as Y,av as D,aw as oe,ax as Q}from"./app_booking.js";function y(t,e,n,s={passive:!0}){return t.addEventListener(e,n,s),()=>t.removeEventListener(e,n)}const re=t=>t.pointerType==="mouse"?typeof t.button!="number"||t.button<=0:t.isPrimary!==!1;function $(t,e="page"){return{point:{x:t[e+"X"],y:t[e+"Y"]}}}const ae=t=>e=>re(e)&&t(e,$(e));function T(t,e,n,s){return y(t,e,ae(n),s)}function j(t){let e=null;return()=>{const n=()=>{e=null};return e===null?(e=t,n):!1}}const ce=j("dragHorizontal"),ue=j("dragVertical");function he(t){let e=!1;{const n=ce(),s=ue();n&&s?e=()=>{n(),s()}:(n&&n(),s&&s())}return e}function Z(){const t=he();return t?(t(),!1):!0}class S{constructor(e){this.isMounted=!1,this.node=e}update(){}}function J(t,e){const n="pointer"+(e?"enter":"leave"),s="onHover"+(e?"Start":"End"),o=(c,a)=>{if(c.type==="touch"||Z())return;const u=t.getProps();t.animationState&&u.whileHover&&t.animationState.setActive("whileHover",e),u[s]&&C.update(()=>u[s](c,a))};return T(t.current,n,o,{passive:!t.getProps()[s]})}class le extends S{mount(){this.unmount=x(J(this.node,!0),J(this.node,!1))}unmount(){}}class de extends S{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=x(y(this.node.current,"focus",()=>this.onFocus()),y(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}const _=(t,e)=>e?t===e?!0:_(t,e.parentElement):!1;function K(t,e){if(!e)return;const n=new PointerEvent("pointer"+t);e(n,$(n))}class pe extends S{constructor(){super(...arguments),this.removeStartListeners=H,this.removeEndListeners=H,this.removeAccessibleListeners=H,this.startPointerPress=(e,n)=>{if(this.removeEndListeners(),this.isPressing)return;const s=this.node.getProps(),o=T(window,"pointerup",(a,u)=>{if(!this.checkPressEnd())return;const{onTap:r,onTapCancel:i}=this.node.getProps();C.update(()=>{_(this.node.current,a.target)?r&&r(a,u):i&&i(a,u)})},{passive:!(s.onTap||s.onPointerUp)}),c=T(window,"pointercancel",(a,u)=>this.cancelPress(a,u),{passive:!(s.onTapCancel||s.onPointerCancel)});this.removeEndListeners=x(o,c),this.startPress(e,n)},this.startAccessiblePress=()=>{const e=c=>{if(c.key!=="Enter"||this.isPressing)return;const a=u=>{u.key!=="Enter"||!this.checkPressEnd()||K("up",(r,i)=>{const{onTap:h}=this.node.getProps();h&&C.update(()=>h(r,i))})};this.removeEndListeners(),this.removeEndListeners=y(this.node.current,"keyup",a),K("down",(u,r)=>{this.startPress(u,r)})},n=y(this.node.current,"keydown",e),s=()=>{this.isPressing&&K("cancel",(c,a)=>this.cancelPress(c,a))},o=y(this.node.current,"blur",s);this.removeAccessibleListeners=x(n,o)}}startPress(e,n){this.isPressing=!0;const{onTapStart:s,whileTap:o}=this.node.getProps();o&&this.node.animationState&&this.node.animationState.setActive("whileTap",!0),s&&C.update(()=>s(e,n))}checkPressEnd(){return this.removeEndListeners(),this.isPressing=!1,this.node.getProps().whileTap&&this.node.animationState&&this.node.animationState.setActive("whileTap",!1),!Z()}cancelPress(e,n){if(!this.checkPressEnd())return;const{onTapCancel:s}=this.node.getProps();s&&C.update(()=>s(e,n))}mount(){const e=this.node.getProps(),n=T(this.node.current,"pointerdown",this.startPointerPress,{passive:!(e.onTapStart||e.onPointerStart)}),s=y(this.node.current,"focus",this.startAccessiblePress);this.removeStartListeners=x(n,s)}unmount(){this.removeStartListeners(),this.removeEndListeners(),this.removeAccessibleListeners()}}const z=new WeakMap,M=new WeakMap,me=t=>{const e=z.get(t.target);e&&e(t)},ve=t=>{t.forEach(me)};function fe({root:t,...e}){const n=t||document;M.has(n)||M.set(n,{});const s=M.get(n),o=JSON.stringify(e);return s[o]||(s[o]=new IntersectionObserver(ve,{root:t,...e})),s[o]}function Pe(t,e,n){const s=fe(e);return z.set(t,n),s.observe(t),()=>{z.delete(t),s.unobserve(t)}}const ge={some:0,all:1};class Ae extends S{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:n,margin:s,amount:o="some",once:c}=e,a={root:n?n.current:void 0,rootMargin:s,threshold:typeof o=="number"?o:ge[o]},u=r=>{const{isIntersecting:i}=r;if(this.isInView===i||(this.isInView=i,c&&!i&&this.hasEnteredView))return;i&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",i);const{onViewportEnter:h,onViewportLeave:m}=this.node.getProps(),v=i?h:m;v&&v(r)};return Pe(this.node.current,a,u)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:n}=this.node;["amount","margin","root"].some(we(e,n))&&this.startObserver()}unmount(){}}function we({viewport:t={}},{viewport:e={}}={}){return n=>t[n]!==e[n]}const ye={inView:{Feature:Ae},tap:{Feature:pe},focus:{Feature:de},hover:{Feature:le}};function ee(t,e){if(!Array.isArray(e))return!1;const n=e.length;if(n!==t.length)return!1;for(let s=0;s<n;s++)if(e[s]!==t[s])return!1;return!0}function B(t,e,n={}){const s=D(t,e,n.custom);let{transition:o=t.getDefaultTransition()||{}}=s||{};n.transitionOverride&&(o=n.transitionOverride);const c=s?()=>Promise.all(Q(t,s,n)):()=>Promise.resolve(),a=t.variantChildren&&t.variantChildren.size?(r=0)=>{const{delayChildren:i=0,staggerChildren:h,staggerDirection:m}=o;return Se(t,e,i+r,h,m,n)}:()=>Promise.resolve(),{when:u}=o;if(u){const[r,i]=u==="beforeChildren"?[c,a]:[a,c];return r().then(()=>i())}else return Promise.all([c(),a(n.delay)])}function Se(t,e,n=0,s=0,o=1,c){const a=[],u=(t.variantChildren.size-1)*s,r=o===1?(i=0)=>i*s:(i=0)=>u-i*s;return Array.from(t.variantChildren).sort(be).forEach((i,h)=>{i.notify("AnimationStart",e),a.push(B(i,e,{...c,delay:n+r(h)}).then(()=>i.notify("AnimationComplete",e)))}),Promise.all(a)}function be(t,e){return t.sortNodePosition(e)}function Ee(t,e,n={}){t.notify("AnimationStart",e);let s;if(Array.isArray(e)){const o=e.map(c=>B(t,c,n));s=Promise.all(o)}else if(typeof e=="string")s=B(t,e,n);else{const o=typeof e=="function"?D(t,e,n.custom):e;s=Promise.all(Q(t,o,n))}return s.then(()=>t.notify("AnimationComplete",e))}const Ce=[...Y].reverse(),xe=Y.length;function Le(t){return e=>Promise.all(e.map(({animation:n,options:s})=>Ee(t,n,s)))}function Te(t){let e=Le(t);const n=Fe();let s=!0;const o=(r,i)=>{const h=D(t,i);if(h){const{transition:m,transitionEnd:v,...f}=h;r={...r,...f,...v}}return r};function c(r){e=r(t)}function a(r,i){const h=t.getProps(),m=t.getVariantContext(!0)||{},v=[],f=new Set;let g={},R=1/0;for(let A=0;A<xe;A++){const p=Ce[A],l=n[p],P=h[p]!==void 0?h[p]:m[p],V=oe(P),F=p===i?l.isActive:null;F===!1&&(R=A);let L=P===m[p]&&P!==h[p]&&V;if(L&&s&&t.manuallyAnimateOnMount&&(L=!1),l.protectedKeys={...g},!l.isActive&&F===null||!P&&!l.prevProp||U(P)||typeof P=="boolean")continue;const W=Ve(l.prevProp,P);let O=W||p===i&&l.isActive&&!L&&V||A>R&&V;const X=Array.isArray(P)?P:[P];let b=X.reduce(o,{});F===!1&&(b={});const{prevResolvedValues:q={}}=l,te={...q,...b},k=d=>{O=!0,f.delete(d),l.needsAnimating[d]=!0};for(const d in te){const E=b[d],I=q[d];g.hasOwnProperty(d)||(E!==I?G(E)&&G(I)?!ee(E,I)||W?k(d):l.protectedKeys[d]=!0:E!==void 0?k(d):f.add(d):E!==void 0&&f.has(d)?k(d):l.protectedKeys[d]=!0)}l.prevProp=P,l.prevResolvedValues=b,l.isActive&&(g={...g,...b}),s&&t.blockInitialAnimation&&(O=!1),O&&!L&&v.push(...X.map(d=>({animation:d,options:{type:p,...r}})))}if(f.size){const A={};f.forEach(p=>{const l=t.getBaseTarget(p);l!==void 0&&(A[p]=l)}),v.push({animation:A})}let N=!!v.length;return s&&h.initial===!1&&!t.manuallyAnimateOnMount&&(N=!1),s=!1,N?e(v):Promise.resolve()}function u(r,i,h){var m;if(n[r].isActive===i)return Promise.resolve();(m=t.variantChildren)===null||m===void 0||m.forEach(f=>{var g;return(g=f.animationState)===null||g===void 0?void 0:g.setActive(r,i)}),n[r].isActive=i;const v=a(h,r);for(const f in n)n[f].protectedKeys={};return v}return{animateChanges:a,setActive:u,setAnimateFunction:c,getState:()=>n}}function Ve(t,e){return typeof e=="string"?e!==t:Array.isArray(e)?!ee(e,t):!1}function w(t=!1){return{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function Fe(){return{animate:w(!0),whileInView:w(),whileHover:w(),whileTap:w(),whileDrag:w(),whileFocus:w(),exit:w()}}class Oe extends S{constructor(e){super(e),e.animationState||(e.animationState=Te(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();this.unmount(),U(e)&&(this.unmount=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:n}=this.node.prevProps||{};e!==n&&this.updateAnimationControlsSubscription()}unmount(){}}let ke=0;class Ie extends S{constructor(){super(...arguments),this.id=ke++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:n,custom:s}=this.node.presenceContext,{isPresent:o}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===o)return;const c=this.node.animationState.setActive("exit",!e,{custom:s??this.node.getProps().custom});n&&!e&&c.then(()=>n(this.id))}mount(){const{register:e}=this.node.presenceContext||{};e&&(this.unmount=e(this.id))}unmount(){}}const He={animation:{Feature:Oe},exit:{Feature:Ie}},Ke=(t,e)=>ne(t)?new se(e,{enableHardwareAcceleration:!1}):new ie(e,{enableHardwareAcceleration:!0}),ze={renderer:Ke,...He,...ye};export{ze as default};
