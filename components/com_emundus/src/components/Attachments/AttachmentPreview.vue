<template>
	<div id="em-attachment-preview">
		<div
			ref="a-preview"
			id="attachment-preview"
			:class="{ 'overflow-x': overflowX, 'overflow-y': overflowY }"
		></div>
		<div id="msg" :class="{ active: msg && openMsg }">
			<p>{{ msg }}</p>
		</div>
	</div>
</template>

<script>
import attachmentService from "../../services/attachment";

export default {
	props: {
		user: {
			type: Number,
			required: true,
		},
	},
	data() {
		return {
			attachment: this.$store.state.attachment.selectedAttachment,
			preview: "",
			overflowX: false,
			overflowY: false,
			style: "",
			msg: "",
			openMsg: false,
		};
	},
	mounted() {
		this.attachment = this.$store.state.attachment.selectedAttachment;
		this.getPreview();
	},
	methods: {
		async getPreview() {
			let data;
			if (!this.$store.state.attachment.previews[this.attachment.aid]) {
				data = await attachmentService.getPreview(
					this.user,
					this.attachment.filename
				);

				// store preview data
				if (data.status) {
					this.$store.commit("attachment/setPreview", {
						preview: data,
						id: this.attachment.aid,
					});
				}
			} else {
				data = this.$store.state.attachment.previews[this.attachment.aid];
			}

			this.$emit("canDownload");
			if (data.status) {
				this.preview = data.content;
				this.overflowX = data.overflowX;
				this.overflowY = data.overflowY;
				this.style = data.style;

				if (data.msg) {
					this.msg = data.msg;
					this.openMsg = true;

					setTimeout(() => {
						this.openMsg = false;
					}, 3000);
				}
			} else {
				if (data.error === "file_not_found") {
					this.$emit("fileNotFound");
				}

				this.overflowX = false;
				this.overflowY = false;
				this.preview = data.content;
				this.msg = "";
			}

			if (this.$refs["a-preview"].shadowRoot === null) {
				this.$refs["a-preview"].attachShadow({ mode: "open" });
			}

			this.$refs["a-preview"].shadowRoot.innerHTML =
				this.preview != null ? this.preview : "";

			if (this.style == "sheet") {
				this.addSheetStyles();
			} else if (this.style == "presentation") {
				this.addPresentationStyles();
			} else if (this.style == "word") {
				this.addWordStyles();
			}
		},
		addSheetStyles() {
			// get div elements of first level
			const pages = this.$refs["a-preview"].shadowRoot.querySelectorAll("div");
			pages.forEach((div, key) => {
				div.style.width = "fit-content";
				div.style.margin = "20px auto";
				div.style.boxShadow = "0px 0px 10px rgba(0, 0, 0, 0.1)";

				if (key > 0) {
					div.style.display = "none";
				}
			});

			const navigation =
				this.$refs["a-preview"].shadowRoot.querySelector(".navigation");
			if (navigation) {
				navigation.style.display = "flex";
				navigation.style.flexDirection = "row";
				navigation.style.justifyContent = "flex-start";
				navigation.style.alignItems = "center";

				navigation.querySelectorAll("li").forEach((li, li_key) => {
					li.style.listStyleType = "none";
					li.style.margin = "0 10px";

					li.addEventListener("click", () => {
						pages.forEach((div, div_key) => {
							if (div_key == li_key) {
								div.style.display = "block";
							} else {
								div.style.display = "none";
							}
						});
					});
				});
			}
		},
		addPresentationStyles() {
			const slides =
				this.$refs["a-preview"].shadowRoot.querySelectorAll(".slide");
			slides.forEach((slide) => {
				slide.style.padding = "16px";
				slide.style.margin = "20px";
				slide.style.width = "calc(100% - 72px)";
				slide.style.boxShadow = "0px 0px 10px rgba(0, 0, 0, 0.1)";
				slide.style.borderRadius = "8px";
				slide.style.backgroundColor = "white";
			});
		},
		addWordStyles() {
			const wrapper =
				this.$refs["a-preview"].shadowRoot.querySelector(".wrapper");

			if (wrapper) {
				wrapper.style.border = "var(--border-color)";
				wrapper.style.boxShadow = "var(--box-shadow)";
				wrapper.style.backgroundColor = "white";
				wrapper.style.padding = "20px";
				wrapper.style.margin = "16px";
				wrapper.style.overflow = "hidden";
			}
		},
	},
	watch: {
		"$store.state.attachment.selectedAttachment": function () {
			// check if selected attchment is not an empty object
			const keys = Object.keys(this.$store.state.attachment.selectedAttachment);

			if (keys.length !== 0) {
				this.attachment = this.$store.state.attachment.selectedAttachment;
				this.openMsg = false;
				this.getPreview();
			}
		},
	},
};
</script>

<style lang="scss" scoped>
#em-attachment-preview {
	width: 60%;
	height: 100%;
	overflow: hidden;
	position: relative;

	#attachment-preview {
		height: 100%;
		width: 100%;
		overflow: hidden;
		background-color: var(--grey-bg-color);

		&.overflow-x {
			overflow-x: auto;
		}

		&.overflow-y {
			overflow-y: auto;
		}
	}

	#msg {
		position: absolute;
		top: 20px;
		left: 8px;
		padding: 16px;
		width: calc(100% - 26px);
		background-color: var(--warning-bg-color);
		color: var(--warning-color);
		opacity: 0;
		z-index: -1;
		transition: all 0.3s;

		&.active {
			opacity: 1;
			z-index: 2;
		}
	}
}
</style>
