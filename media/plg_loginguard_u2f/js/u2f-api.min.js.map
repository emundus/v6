{"version":3,"sources":["u2f-api.js"],"names":[],"mappings":"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","file":"u2f-api.min.js","sourcesContent":["/*!\n * Copyright 2014-2015 Google Inc. All rights reserved.\n *\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file or at\n * https://developers.google.com/open-source/licenses/bsd\n *\n * This file comes from the U2F API Polyfill retrieved from https://github.com/mastahyeti/u2f-api\n */\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n\n(function (){\n    var isChrome = 'chrome' in window && window.navigator.userAgent.indexOf('Edge') < 0;\n    if ('u2f' in window || !isChrome) {\n        return;\n    }\n\n    /** Namespace for the U2F api.\n     * @type {Object}\n     */\n    var u2f = window.u2f = {};\n\n    /**\n     * FIDO U2F Javascript API Version\n     * @number\n     */\n    var js_api_version;\n\n    /**\n     * The U2F extension id\n     * @const {string}\n     */\n    // The Chrome packaged app extension ID.\n    // Uncomment this if you want to deploy a server instance that uses\n    // the package Chrome app and does not require installing the U2F Chrome extension.\n    u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n    // The U2F Chrome extension ID.\n    // Uncomment this if you want to deploy a server instance that uses\n    // the U2F Chrome extension to authenticate.\n    // u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';\n\n\n    /**\n     * Message types for messsages to/from the extension\n     * @const\n     * @enum {string}\n     */\n    u2f.MessageTypes = {\n        'U2F_REGISTER_REQUEST': 'u2f_register_request',\n        'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n        'U2F_SIGN_REQUEST': 'u2f_sign_request',\n        'U2F_SIGN_RESPONSE': 'u2f_sign_response',\n        'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',\n        'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'\n    };\n\n\n    /**\n     * Response status codes\n     * @const\n     * @enum {number}\n     */\n    u2f.ErrorCodes = {\n        'OK': 0,\n        'OTHER_ERROR': 1,\n        'BAD_REQUEST': 2,\n        'CONFIGURATION_UNSUPPORTED': 3,\n        'DEVICE_INELIGIBLE': 4,\n        'TIMEOUT': 5\n    };\n\n\n    /**\n     * A message for registration requests\n     * @typedef {{\n   *   type: u2f.MessageTypes,\n   *   appId: ?string,\n   *   timeoutSeconds: ?number,\n   *   requestId: ?number\n   * }}\n     */\n    u2f.U2fRequest;\n\n\n    /**\n     * A message for registration responses\n     * @typedef {{\n   *   type: u2f.MessageTypes,\n   *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n   *   requestId: ?number\n   * }}\n     */\n    u2f.U2fResponse;\n\n\n    /**\n     * An error object for responses\n     * @typedef {{\n   *   errorCode: u2f.ErrorCodes,\n   *   errorMessage: ?string\n   * }}\n     */\n    u2f.Error;\n\n    /**\n     * Data object for a single sign request.\n     * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC}}\n     */\n    u2f.Transport;\n\n\n    /**\n     * Data object for a single sign request.\n     * @typedef {Array<u2f.Transport>}\n     */\n    u2f.Transports;\n\n    /**\n     * Data object for a single sign request.\n     * @typedef {{\n   *   version: string,\n   *   challenge: string,\n   *   keyHandle: string,\n   *   appId: string\n   * }}\n     */\n    u2f.SignRequest;\n\n\n    /**\n     * Data object for a sign response.\n     * @typedef {{\n   *   keyHandle: string,\n   *   signatureData: string,\n   *   clientData: string\n   * }}\n     */\n    u2f.SignResponse;\n\n\n    /**\n     * Data object for a registration request.\n     * @typedef {{\n   *   version: string,\n   *   challenge: string\n   * }}\n     */\n    u2f.RegisterRequest;\n\n\n    /**\n     * Data object for a registration response.\n     * @typedef {{\n   *   version: string,\n   *   keyHandle: string,\n   *   transports: Transports,\n   *   appId: string\n   * }}\n     */\n    u2f.RegisterResponse;\n\n\n    /**\n     * Data object for a registered key.\n     * @typedef {{\n   *   version: string,\n   *   keyHandle: string,\n   *   transports: ?Transports,\n   *   appId: ?string\n   * }}\n     */\n    u2f.RegisteredKey;\n\n\n    /**\n     * Data object for a get API register response.\n     * @typedef {{\n   *   js_api_version: number\n   * }}\n     */\n    u2f.GetJsApiVersionResponse;\n\n\n    //Low level MessagePort API support\n\n    /**\n     * Sets up a MessagePort to the U2F extension using the\n     * available mechanisms.\n     * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n     */\n    u2f.getMessagePort = function(callback) {\n        if (typeof chrome != 'undefined' && chrome.runtime) {\n            // The actual message here does not matter, but we need to get a reply\n            // for the callback to run. Thus, send an empty signature request\n            // in order to get a failure response.\n            var msg = {\n                type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n                signRequests: []\n            };\n            chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n                if (!chrome.runtime.lastError) {\n                    // We are on a whitelisted origin and can talk directly\n                    // with the extension.\n                    u2f.getChromeRuntimePort_(callback);\n                } else {\n                    // chrome.runtime was available, but we couldn't message\n                    // the extension directly, use iframe\n                    u2f.getIframePort_(callback);\n                }\n            });\n        } else if (u2f.isAndroidChrome_()) {\n            u2f.getAuthenticatorPort_(callback);\n        } else if (u2f.isIosChrome_()) {\n            u2f.getIosPort_(callback);\n        } else {\n            // chrome.runtime was not available at all, which is normal\n            // when this origin doesn't have access to any extensions.\n            u2f.getIframePort_(callback);\n        }\n    };\n\n    /**\n     * Detect chrome running on android based on the browser's useragent.\n     * @private\n     */\n    u2f.isAndroidChrome_ = function() {\n        var userAgent = navigator.userAgent;\n        return userAgent.indexOf('Chrome') != -1 &&\n            userAgent.indexOf('Android') != -1;\n    };\n\n    /**\n     * Detect chrome running on iOS based on the browser's platform.\n     * @private\n     */\n    u2f.isIosChrome_ = function() {\n        return [\"iPhone\", \"iPad\", \"iPod\"].indexOf(navigator.platform) > -1;\n    };\n\n    /**\n     * Connects directly to the extension via chrome.runtime.connect.\n     * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n     * @private\n     */\n    u2f.getChromeRuntimePort_ = function(callback) {\n        var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n            {'includeTlsChannelId': true});\n        setTimeout(function() {\n            callback(new u2f.WrappedChromeRuntimePort_(port));\n        }, 0);\n    };\n\n    /**\n     * Return a 'port' abstraction to the Authenticator app.\n     * @param {function(u2f.WrappedAuthenticatorPort_)} callback\n     * @private\n     */\n    u2f.getAuthenticatorPort_ = function(callback) {\n        setTimeout(function() {\n            callback(new u2f.WrappedAuthenticatorPort_());\n        }, 0);\n    };\n\n    /**\n     * Return a 'port' abstraction to the iOS client app.\n     * @param {function(u2f.WrappedIosPort_)} callback\n     * @private\n     */\n    u2f.getIosPort_ = function(callback) {\n        setTimeout(function() {\n            callback(new u2f.WrappedIosPort_());\n        }, 0);\n    };\n\n    /**\n     * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n     * @param {Port} port\n     * @constructor\n     * @private\n     */\n    u2f.WrappedChromeRuntimePort_ = function(port) {\n        this.port_ = port;\n    };\n\n    /**\n     * Format and return a sign request compliant with the JS API version supported by the extension.\n     * @param {Array<u2f.SignRequest>} signRequests\n     * @param {number} timeoutSeconds\n     * @param {number} reqId\n     * @return {Object}\n     */\n    u2f.formatSignRequest_ =\n        function(appId, challenge, registeredKeys, timeoutSeconds, reqId) {\n            if (js_api_version === undefined || js_api_version < 1.1) {\n                // Adapt request to the 1.0 JS API\n                var signRequests = [];\n                for (var i = 0; i < registeredKeys.length; i++) {\n                    signRequests[i] = {\n                        version: registeredKeys[i].version,\n                        challenge: challenge,\n                        keyHandle: registeredKeys[i].keyHandle,\n                        appId: appId\n                    };\n                }\n                return {\n                    type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n                    signRequests: signRequests,\n                    timeoutSeconds: timeoutSeconds,\n                    requestId: reqId\n                };\n            }\n            // JS 1.1 API\n            return {\n                type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n                appId: appId,\n                challenge: challenge,\n                registeredKeys: registeredKeys,\n                timeoutSeconds: timeoutSeconds,\n                requestId: reqId\n            };\n        };\n\n    /**\n     * Format and return a register request compliant with the JS API version supported by the extension..\n     * @param {Array<u2f.SignRequest>} signRequests\n     * @param {Array<u2f.RegisterRequest>} signRequests\n     * @param {number} timeoutSeconds\n     * @param {number} reqId\n     * @return {Object}\n     */\n    u2f.formatRegisterRequest_ =\n        function(appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {\n            if (js_api_version === undefined || js_api_version < 1.1) {\n                // Adapt request to the 1.0 JS API\n                for (var i = 0; i < registerRequests.length; i++) {\n                    registerRequests[i].appId = appId;\n                }\n                var signRequests = [];\n                for (var i = 0; i < registeredKeys.length; i++) {\n                    signRequests[i] = {\n                        version: registeredKeys[i].version,\n                        challenge: registerRequests[0],\n                        keyHandle: registeredKeys[i].keyHandle,\n                        appId: appId\n                    };\n                }\n                return {\n                    type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n                    signRequests: signRequests,\n                    registerRequests: registerRequests,\n                    timeoutSeconds: timeoutSeconds,\n                    requestId: reqId\n                };\n            }\n            // JS 1.1 API\n            return {\n                type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n                appId: appId,\n                registerRequests: registerRequests,\n                registeredKeys: registeredKeys,\n                timeoutSeconds: timeoutSeconds,\n                requestId: reqId\n            };\n        };\n\n\n    /**\n     * Posts a message on the underlying channel.\n     * @param {Object} message\n     */\n    u2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n        this.port_.postMessage(message);\n    };\n\n\n    /**\n     * Emulates the HTML 5 addEventListener interface. Works only for the\n     * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n     * @param {string} eventName\n     * @param {function({data: Object})} handler\n     */\n    u2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n        function(eventName, handler) {\n            var name = eventName.toLowerCase();\n            if (name == 'message' || name == 'onmessage') {\n                this.port_.onMessage.addListener(function(message) {\n                    // Emulate a minimal MessageEvent object\n                    handler({'data': message});\n                });\n            } else {\n                console.error('WrappedChromeRuntimePort only supports onMessage');\n            }\n        };\n\n    /**\n     * Wrap the Authenticator app with a MessagePort interface.\n     * @constructor\n     * @private\n     */\n    u2f.WrappedAuthenticatorPort_ = function() {\n        this.requestId_ = -1;\n        this.requestObject_ = null;\n    }\n\n    /**\n     * Launch the Authenticator intent.\n     * @param {Object} message\n     */\n    u2f.WrappedAuthenticatorPort_.prototype.postMessage = function(message) {\n        var intentUrl =\n            u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ +\n            ';S.request=' + encodeURIComponent(JSON.stringify(message)) +\n            ';end';\n        document.location = intentUrl;\n    };\n\n    /**\n     * Tells what type of port this is.\n     * @return {String} port type\n     */\n    u2f.WrappedAuthenticatorPort_.prototype.getPortType = function() {\n        return \"WrappedAuthenticatorPort_\";\n    };\n\n\n    /**\n     * Emulates the HTML 5 addEventListener interface.\n     * @param {string} eventName\n     * @param {function({data: Object})} handler\n     */\n    u2f.WrappedAuthenticatorPort_.prototype.addEventListener = function(eventName, handler) {\n        var name = eventName.toLowerCase();\n        if (name == 'message') {\n            var self = this;\n            /* Register a callback to that executes when\n             * chrome injects the response. */\n            window.addEventListener(\n                'message', self.onRequestUpdate_.bind(self, handler), false);\n        } else {\n            console.error('WrappedAuthenticatorPort only supports message');\n        }\n    };\n\n    /**\n     * Callback invoked  when a response is received from the Authenticator.\n     * @param function({data: Object}) callback\n     * @param {Object} message message Object\n     */\n    u2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ =\n        function(callback, message) {\n            var messageObject = JSON.parse(message.data);\n            var intentUrl = messageObject['intentURL'];\n\n            var errorCode = messageObject['errorCode'];\n            var responseObject = null;\n            if (messageObject.hasOwnProperty('data')) {\n                responseObject = /** @type {Object} */ (\n                    JSON.parse(messageObject['data']));\n            }\n\n            callback({'data': responseObject});\n        };\n\n    /**\n     * Base URL for intents to Authenticator.\n     * @const\n     * @private\n     */\n    u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ =\n        'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';\n\n    /**\n     * Wrap the iOS client app with a MessagePort interface.\n     * @constructor\n     * @private\n     */\n    u2f.WrappedIosPort_ = function() {};\n\n    /**\n     * Launch the iOS client app request\n     * @param {Object} message\n     */\n    u2f.WrappedIosPort_.prototype.postMessage = function(message) {\n        var str = JSON.stringify(message);\n        var url = \"u2f://auth?\" + encodeURI(str);\n        location.replace(url);\n    };\n\n    /**\n     * Tells what type of port this is.\n     * @return {String} port type\n     */\n    u2f.WrappedIosPort_.prototype.getPortType = function() {\n        return \"WrappedIosPort_\";\n    };\n\n    /**\n     * Emulates the HTML 5 addEventListener interface.\n     * @param {string} eventName\n     * @param {function({data: Object})} handler\n     */\n    u2f.WrappedIosPort_.prototype.addEventListener = function(eventName, handler) {\n        var name = eventName.toLowerCase();\n        if (name !== 'message') {\n            console.error('WrappedIosPort only supports message');\n        }\n    };\n\n    /**\n     * Sets up an embedded trampoline iframe, sourced from the extension.\n     * @param {function(MessagePort)} callback\n     * @private\n     */\n    u2f.getIframePort_ = function(callback) {\n        // Create the iframe\n        var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n        var iframe = document.createElement('iframe');\n        iframe.src = iframeOrigin + '/u2f-comms.html';\n        iframe.setAttribute('style', 'display:none');\n        document.body.appendChild(iframe);\n\n        var channel = new MessageChannel();\n        var ready = function(message) {\n            if (message.data == 'ready') {\n                channel.port1.removeEventListener('message', ready);\n                callback(channel.port1);\n            } else {\n                console.error('First event on iframe port was not \"ready\"');\n            }\n        };\n        channel.port1.addEventListener('message', ready);\n        channel.port1.start();\n\n        iframe.addEventListener('load', function() {\n            // Deliver the port to the iframe and initialize\n            iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n        });\n    };\n\n\n    //High-level JS API\n\n    /**\n     * Default extension response timeout in seconds.\n     * @const\n     */\n    u2f.EXTENSION_TIMEOUT_SEC = 30;\n\n    /**\n     * A singleton instance for a MessagePort to the extension.\n     * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n     * @private\n     */\n    u2f.port_ = null;\n\n    /**\n     * Callbacks waiting for a port\n     * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n     * @private\n     */\n    u2f.waitingForPort_ = [];\n\n    /**\n     * A counter for requestIds.\n     * @type {number}\n     * @private\n     */\n    u2f.reqCounter_ = 0;\n\n    /**\n     * A map from requestIds to client callbacks\n     * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n   *                       |function((u2f.Error|u2f.SignResponse)))>}\n     * @private\n     */\n    u2f.callbackMap_ = {};\n\n    /**\n     * Creates or retrieves the MessagePort singleton to use.\n     * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n     * @private\n     */\n    u2f.getPortSingleton_ = function(callback) {\n        if (u2f.port_) {\n            callback(u2f.port_);\n        } else {\n            if (u2f.waitingForPort_.length == 0) {\n                u2f.getMessagePort(function(port) {\n                    u2f.port_ = port;\n                    u2f.port_.addEventListener('message',\n                        /** @type {function(Event)} */ (u2f.responseHandler_));\n\n                    // Careful, here be async callbacks. Maybe.\n                    while (u2f.waitingForPort_.length)\n                        u2f.waitingForPort_.shift()(u2f.port_);\n                });\n            }\n            u2f.waitingForPort_.push(callback);\n        }\n    };\n\n    /**\n     * Handles response messages from the extension.\n     * @param {MessageEvent.<u2f.Response>} message\n     * @private\n     */\n    u2f.responseHandler_ = function(message) {\n        var response = message.data;\n        var reqId = response['requestId'];\n        if (!reqId || !u2f.callbackMap_[reqId]) {\n            console.error('Unknown or missing requestId in response.');\n            return;\n        }\n        var cb = u2f.callbackMap_[reqId];\n        delete u2f.callbackMap_[reqId];\n        cb(response['responseData']);\n    };\n\n    /**\n     * Dispatches an array of sign requests to available U2F tokens.\n     * If the JS API version supported by the extension is unknown, it first sends a\n     * message to the extension to find out the supported API version and then it sends\n     * the sign request.\n     * @param {string=} appId\n     * @param {string=} challenge\n     * @param {Array<u2f.RegisteredKey>} registeredKeys\n     * @param {function((u2f.Error|u2f.SignResponse))} callback\n     * @param {number=} opt_timeoutSeconds\n     */\n    u2f.sign = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n        if (js_api_version === undefined) {\n            // Send a message to get the extension to JS API version, then send the actual sign request.\n            u2f.getApiVersion(\n                function (response) {\n                    js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n                    console.log(\"Extension JS API Version: \", js_api_version);\n                    u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n                });\n        } else {\n            // We know the JS API version. Send the actual sign request in the supported API version.\n            u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n        }\n    };\n\n    /**\n     * Dispatches an array of sign requests to available U2F tokens.\n     * @param {string=} appId\n     * @param {string=} challenge\n     * @param {Array<u2f.RegisteredKey>} registeredKeys\n     * @param {function((u2f.Error|u2f.SignResponse))} callback\n     * @param {number=} opt_timeoutSeconds\n     */\n    u2f.sendSignRequest = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n        u2f.getPortSingleton_(function(port) {\n            var reqId = ++u2f.reqCounter_;\n            u2f.callbackMap_[reqId] = callback;\n            var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n                opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n            var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);\n            port.postMessage(req);\n        });\n    };\n\n    /**\n     * Dispatches register requests to available U2F tokens. An array of sign\n     * requests identifies already registered tokens.\n     * If the JS API version supported by the extension is unknown, it first sends a\n     * message to the extension to find out the supported API version and then it sends\n     * the register request.\n     * @param {string=} appId\n     * @param {Array<u2f.RegisterRequest>} registerRequests\n     * @param {Array<u2f.RegisteredKey>} registeredKeys\n     * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n     * @param {number=} opt_timeoutSeconds\n     */\n    u2f.register = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n        if (js_api_version === undefined) {\n            // Send a message to get the extension to JS API version, then send the actual register request.\n            u2f.getApiVersion(\n                function (response) {\n                    js_api_version = response['js_api_version'] === undefined ? 0: response['js_api_version'];\n                    console.log(\"Extension JS API Version: \", js_api_version);\n                    u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n                        callback, opt_timeoutSeconds);\n                });\n        } else {\n            // We know the JS API version. Send the actual register request in the supported API version.\n            u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n                callback, opt_timeoutSeconds);\n        }\n    };\n\n    /**\n     * Dispatches register requests to available U2F tokens. An array of sign\n     * requests identifies already registered tokens.\n     * @param {string=} appId\n     * @param {Array<u2f.RegisterRequest>} registerRequests\n     * @param {Array<u2f.RegisteredKey>} registeredKeys\n     * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n     * @param {number=} opt_timeoutSeconds\n     */\n    u2f.sendRegisterRequest = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n        u2f.getPortSingleton_(function(port) {\n            var reqId = ++u2f.reqCounter_;\n            u2f.callbackMap_[reqId] = callback;\n            var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n                opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n            var req = u2f.formatRegisterRequest_(\n                appId, registeredKeys, registerRequests, timeoutSeconds, reqId);\n            port.postMessage(req);\n        });\n    };\n\n\n    /**\n     * Dispatches a message to the extension to find out the supported\n     * JS API version.\n     * If the user is on a mobile phone and is thus using Google Authenticator instead\n     * of the Chrome extension, don't send the request and simply return 0.\n     * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback\n     * @param {number=} opt_timeoutSeconds\n     */\n    u2f.getApiVersion = function(callback, opt_timeoutSeconds) {\n        u2f.getPortSingleton_(function(port) {\n            // If we are using Android Google Authenticator or iOS client app,\n            // do not fire an intent to ask which JS API version to use.\n            if (port.getPortType) {\n                var apiVersion;\n                switch (port.getPortType()) {\n                    case 'WrappedIosPort_':\n                    case 'WrappedAuthenticatorPort_':\n                        apiVersion = 1.1;\n                        break;\n\n                    default:\n                        apiVersion = 0;\n                        break;\n                }\n                callback({ 'js_api_version': apiVersion });\n                return;\n            }\n            var reqId = ++u2f.reqCounter_;\n            u2f.callbackMap_[reqId] = callback;\n            var req = {\n                type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,\n                timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n                    opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n                requestId: reqId\n            };\n            port.postMessage(req);\n        });\n    };\n})();\n"]}